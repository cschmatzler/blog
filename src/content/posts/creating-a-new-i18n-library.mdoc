---
draft: true
title: Creating a new internationalisation library for Elixir
date: 2023-08-04
description: |
  I ran into some roadblocks when translating a project, so I wrote a thing.
---

I just pushed the initial version of [Idiom](https://hex.pm/packages/idiom) and I think it's pretty cool. This is a little write-up on why I wrote it, why its
API is the way it is, and what I plan to do with it in the future.

## How we got here

While I was working on one of my way too many side projects, I needed a way to internationalise the user interface. Having *some* experience with
[gettext](https://hex.pm/packages/gettext), I looked around to see if I could take it farther. My optimal choice of internationalisation library should

- Be editable outside of the editor while not requiring me to import/export all the time.  
Text files are great, and I don't mind the `po` format at all. It's not super approachable to linguists and (I'm sorry) friends and family, though, and trying 
to provide them with a proper user interface to edit translation historically required a "Export keys -> Import to editor -> Edit translations -> Export from 
editor -> Commit to repository" workflow. This isn't ideal.

- Allow copy updates without re-deploying my application.  
Pushing a commit with a fix for a simple typo in some copy, having to rebuild the entire application, followed by triggering a new release/deployment is a pain
in the ass. We can do better. There's a bunch of localisation management solutions that offer over-the-air APIs. Push a button, have your fixed copy appear in
the application.

`gettext` solves neither of these problems, and another localisation library in Elixir essentially doesn't exist.

## Designing an API

So, after deciding to create a thing, I needed to come up with an API for it.  
Looking through all kinds of different localisation libraries for different languages, I figured that a little ~~stealing~~ inspiration has never hurt anyone,
so Idiom's API is relatively close to [i18next](https://i18next.com) - they did a fantastic job in creating an ergonomic library and if you ever need
localisation in the TypeScript world, I highly recommend checking them out.

Here's some examples:

```elixir
# Set the locale
Idiom.put_locale("en-US")

t("landing.welcome")

# With natural language key
t("Hello Idiom!")

# With interpolation
t("Good morning, {{name}}. We hope you are having a great day.", %{name: "Tim"})

# With plural and interpolation
t("You need to buy {{count}} carrots", count: 1)

# With namespace
t("Create your account", namespace: "signup")
Idiom.put_namespace("signup")
t("Create your account")

# With explicit locale
t("Create your account", to: "fr")

# With fallback locale
t("Create your account", to: "fr", fallback: "en")
```

As you can see, Idiom comes with one main function, `t/3`, and a few utilities. 

### Starting with `gettext`

As a starter, I looked at what I was familiar with: `gettext` and its multiple different functions that are slightly different but still the same. With 
`gettext`, if you want to just translate a key, you use the `gettext(key)` function. What if you want to change the domain (Idiom calls it namespace), though?
Your call becomes `dgettext(domain, key)`. For plurals, it's `ngettext(msgid, msgid_plural, n)`. Plurals **and** domain? 
`dngettext(domain, msgid, msgid_plural, n)`. In order to use the library, you have to remember all the prefixes for each part of functionality, and the order
in which to combine them.  
You will end up with something like

```elixir
dngettext(
  "errors",
  "Here is the string to translate",
  "Here are the strings to translate",
  3
)
```

### Being different

This always felt incredibly unergonomic to me, especially when Elixir comes with the wonderful convention of adding an `opts` keyword list to functions.

In Idiom, if you want a different namespace, pass a `namespace` option. Want to pluralise something? Add a `count` option. Want both? Well, add both options.  
Compare the `dngettext/4` example from above to how Idiom does it:

```elixir
t("Here is the string to translate", namespace: "errors", count: 3)
```

Note that you do not need to pass both singular and plural versions to `t/3` as Idiom automatically tries to resolve the different available plural suffixes
(`zero`, `one`, `two`, `few`, `many`, `other`)
In the background, the call above will resolve the suffix matching the count 3 in your locale. In English, this would be `other`, resulting in the key
`Here is the string to translate_other`, in Arabic it would be `few`. Luckily, the Unicode Consortium keeps an updated
[list of all plural rules](https://github.com/cschmatzler/idiom/blob/main/priv/idiom/plurals.json) Idiom is parsing to support plurals properly.

## What's next?

Idiom is usable at this point, but will probably not see a `1.0` release in a while. There's a few things I'd like to work on before taking that step and
calling the library ready for production.

### Improved test coverage and documentation

The test coverage is okay at the moment, but specifically lacks tests for right-to-left languages, and some combinations of options that could be considered
edge cases. In addition, some edge cases are not yet covered by the documentation (what happens if you call `t("{{count}} apples", %{count: 2}, count: 3)`? I
know the behaviour, but outside of looking at the code, it's not documented anywhere). Documentation is one area where perfectionism might be warranted.

### Support for multiple OTA providers

Right now, the number is zero. It should be higher. 

### Validation of performance assumptions

I am relatively confident in my choice of using an ETS table as message storage. With `read_concurrency`, it should never be the bottleneck in your
application. Alas, that confidence might be completely unearned, and I might be wrong. Some numbers would be nice. Since Idiom is part of every render path of
every part of your application, performance is actually kinda important.
